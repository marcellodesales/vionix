####
#### Author: Marcello DeSales (@mdesales)
####
# Viasat DevSecOps Platform workflow for Kubernetes CloudNative CD deployments

name: kubernetes-kustomize-devsecops-workflow

on:
  # Manual workflow execution
  # https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch
  # https://github.com/actions/runner/issues/1483#issuecomment-969295757
  # https://github.com/orgs/community/discussions/25595#discussioncomment-3248417
  workflow_call:
    inputs:
      seceng-devsecops-dind-runner-label:
        description: "Docker-in-docker (dind) runner to use base label"
        required: false
        type: string
        # Base image for the label is at https://git.viasat.com/seceng-devsecops-platform/devsecops-platform-runtime-github_actions_runner
        default: devsecops

      kubectl-version:
        description: "The version of Kubectl to use"
        required: false
        type: string
        default: v1.22.0

      continue-on-yamllint-errors:
        description: "Whether or not we continue running the workflow when yamllint errors are found"
        required: false
        type: string
        default: true

      yamllint-config:
        description: "The configuration for yamllint"
        required: false
        type: string
        default: |
          extends: default
          rules:
            line-length: disable
            document-start: disable
            empty-lines:
              level: warning
            new-line-at-end-of-file:
              level: warning
            trailing-spaces:
              level: warning

      kustomize-version:
        description: "The version of kustomization to use"
        required: false
        type: string
        default: "."
        
      check-kustomization:
        description: "Whether or not check for kustomization files"
        required: false
        type: string
        default: false

      check-argocd:
        description: "Whether or not check for argocd files"
        required: false
        type: string
        default: false

      argocd-server:
        description: "The ArgoCD server to use"
        required: false
        type: string
        default: https://argo-cd.viarise.viasat.io

    # We need to declare the intent of secrets. The pipelines reusing this must declare them!
    # https://github.com/orgs/community/discussions/26749#discussioncomment-3253230
    secrets:
      KUBERNETES_KUBECONFIG:
        description: "The base64 value of HOME/.kube/config to access the cluster"
        required: false

      ARGOCD_TOKEN:
        description: "The base64 value of ArgoCD token from ARGOCD_SERVER/settings/accounts/XYZ"
        required: false

      ARTIFACTORY_SVC_USER:
        description: "The username of the service account for Artifactory Docker registry Repository"
        required: false

      ARTIFACTORY_SVC_PASS:
        description: "The password associated with the username of the service account for Artifactory Docker registry Repository"
        required: false

      SLACK_CHANNEL_AUTOMATION_ID:
        description: "The Slack Automation ID"
        required: false

      SLACK_CHANNEL_AUTOMATION_TOKEN:
        description: "The token for the given Slack channel ID"
        required: false


# https://faun.pub/building-a-ci-cd-pipeline-with-github-actions-and-docker-part-1-a9d8709c31fb
jobs:

  code:
    name: 🔧 code
    # https://stackoverflow.com/questions/69759538/use-an-array-in-workflow-level-env-variable
    runs-on: fromJson( ${{ inputs.seceng-devsecops-dind-runner-label }} )


    permissions:
      # Maybe to get twistlock action to run we need permission to read
      # https://github.com/actions/checkout/issues/254#issuecomment-1166945991
      contents: read  # <--- allows to read repo
      # Enable pull request reads for 8BitJonny/gh-get-current-pr, avoid error "Resource not accessible by integration"
      # https://github.com/actions/first-interaction/issues/10#issuecomment-1232740076
      pull-requests: read

    # https://github.community/t/sharing-a-variable-between-jobs/16967/14
    outputs:
      # >> $GITHUB_OUTPUT in each of the steps[name].outputs is defined is where these are defined for the job
      githubActionJobName: ${{steps.set_base_values.outputs.githubActionJobName}}
      githubActionJobUrl: ${{steps.set_base_values.outputs.githubActionJobUrl}}
      githubActionRunId: ${{steps.set_base_values.outputs.githubActionRunId}}
      githubOrg: ${{steps.set_base_values.outputs.githubOrg}}
      defaultDockerImageVersion: ${{steps.set_base_values.outputs.defaultDockerImageVersion}}
      defaultDockerImageBranchTag: ${{steps.set_base_values.outputs.defaultDockerImageBranchTag}}
      defaultDockerImageBranchShaTag: ${{steps.set_base_values.outputs.defaultDockerImageBranchShaTag}}
      defaultDockerImageBranchTagForVersion: ${{steps.set_base_values.outputs.defaultDockerImageBranchTagForVersion}}
      dockerContextPath: ${{steps.set_base_values.outputs.dockerContextPath}}
      jobStartTimestamp: ${{steps.set_base_values.outputs.jobStartTimestamp}}
      gitShortSha: ${{steps.set_base_values.outputs.gitShortSha}}
      committerName: ${{steps.set_base_values.outputs.committerName}}
      committerEmail: ${{steps.set_base_values.outputs.committerEmail}}
      buildDateTime: ${{steps.set_base_values.outputs.buildDateTime}}
      gitopsDeployEnv: ${{steps.set_base_values.outputs.gitopsDeployEnv}}
      gitopsDeployUrl: ${{steps.set_base_values.outputs.gitopsDeployUrl}}
      gitopsDeploySegment: ${{steps.set_base_values.outputs.gitopsDeploySegment}}
      gitopsDeployTargetRepo: ${{steps.set_base_values.outputs.gitopsDeployTargetRepo}}
      gitopsDeployTargetRepoBranch: ${{steps.set_base_values.outputs.gitopsDeployTargetRepoBranch}}
      gitopsDeployTargetProvider: ${{steps.set_base_values.outputs.gitopsDeployTargetProvider}}
      gitopsDeployTargetRegion: ${{steps.set_base_values.outputs.gitopsDeployTargetRegion}}
      gitopsDeployTargetType: ${{steps.set_base_values.outputs.gitopsDeployTargetType}}
      gitopsDeployVersion: ${{steps.set_base_values.outputs.gitopsDeployVersion}}
      hasKubeconfig: ${{steps.set-base-values.outputs.hasKubeconfig}}

      kustomizeFilesMatrix: ${{ steps.kustomize-updates.outputs.filesMatrix }}
      requiresKustomizeProcessing: ${{ steps.kustomize-updates.outputs.requiresProcessing }}
      affectedKustomizeDirs: ${{ steps.kustomize-updates.outputs.affectedDirs }}

      argocdFilesMatrix: ${{ steps.argocd-updates.outputs.filesMatrix }}
      requiresArgocdProcessing: ${{ steps.argocd-updates.outputs.requiresProcessing }}
      affectedArgocdFiles: ${{ steps.argocd-updates.outputs.affectedDirs }}

    steps:
      - name: Provided input to the app
        run: |
          echo "Inputs=${{ toJSON(inputs) }}"

      - name: Annotate Job with current information
        run: |
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-markdown-content
          echo "# 🔧 \`code\` Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Annotate Job with current information
        run: |
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-markdown-content
          echo "## :white_check_mark: Set environment variables" >> $GITHUB_STEP_SUMMARY
          #echo "## :recycle: Needs refactoring" >> $GITHUB_STEP_SUMMARY
          #echo "* Installed latest git to self-hosted to be able to see the .git metadata dir " >> $GITHUB_STEP_SUMMARY
          #echo "  * https://github.com/actions/checkout/issues/335#issuecomment-763159788 " >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Fetch all history and have .git locally for inspection
        uses: viarise/checkout@v3.5.3
        with:
          fetch-depth: 0

      # Write directly to GITHUB_ENV so that all steps have access to the same values
      # https://docs.github.com/en/actions/learn-github-actions/environment-variables#passing-values-between-steps-and-jobs-in-a-workflow
      - name: Set default envs from for tags and names
        run: |
          env
          echo "DEFAULT_DOCKER_IMAGE_VERSION=${GITHUB_SHA}" >> $GITHUB_ENV
          # The repo name only without refs
          # https://stackoverflow.com/questions/13570327/how-to-delete-a-substring-using-shell-script/46104342#46104342
          REMOVE="refs/heads/"
          BRANCH_TAG=${GITHUB_REF/$REMOVE/}
          REMOVE="refs/tags/"
          BRANCH_TAG=${BRANCH_TAG/$REMOVE/}
          echo "BRANCH_TAG=${BRANCH_TAG}" >> $GITHUB_ENV
          # Remove the / from topic branches for versions, etc:
          BRANCH_TAG_FOR_VERSION=$(echo ${BRANCH_TAG} | sed -e 's/\//-/g')
          BRANCH_TAG_FOR_VERSION=$(echo ${BRANCH_TAG_FOR_VERSION} | sed -e 's/#/-/g')
          echo "BRANCH_TAG_FOR_VERSION=${BRANCH_TAG_FOR_VERSION}" >> $GITHUB_ENV
          # The branch and sha together makes it easier to find
          GIT_SHORT_SHA=${GITHUB_SHA:0:7}
          echo "GIT_SHORT_SHA=${GIT_SHORT_SHA}" >> $GITHUB_ENV
          echo "BRANCH_SHA_TAG=${GIT_SHORT_SHA}-${BRANCH_TAG_FOR_VERSION}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_APP_VERSION=${GIT_SHORT_SHA}-${BRANCH_TAG_FOR_VERSION}" >> $GITHUB_ENV
          # For the job run
          echo "BUILD_JOB_NAME=${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" >> $GITHUB_ENV
          echo "BUILD_JOB_URL=${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" >> $GITHUB_ENV
          # https://stackoverflow.com/questions/60942067/get-current-date-and-time-in-github-workflows/60942437#60942437
          BUILD_DATE_TIME=$(date +'%Y-%m-%d %H:%m:%S %Z')
          echo "BUILD_DATE_TIME=${BUILD_DATE_TIME}" >> $GITHUB_ENV
          JOB_TIMESTAMP=$(date +%s)
          echo "JOB_TIMESTAMP=${JOB_TIMESTAMP}" >> $GITHUB_ENV
          # https://git-scm.com/docs/git-show
          COMMITTER_NAME=$(git --no-pager show -s --format="%an")
          echo "COMMITTER_NAME=${COMMITTER_NAME}" >> $GITHUB_ENV
          COMMITTER_EMAIL=$(git --no-pager show -s --format="%ae")
          echo "COMMITTER_EMAIL=${COMMITTER_EMAIL}" >> $GITHUB_ENV
          env

      - name: Setting values
        id: set_base_values
        run: |
          echo "githubActionJobName=$BUILD_JOB_NAME" >> $GITHUB_OUTPUT  # Duplicate without braces
          echo "githubActionJobUrl=$BUILD_JOB_URL" >> $GITHUB_OUTPUT  # Duplicate without braces
          echo "githubActionRunId=$GITHUB_RUN_ID" >> $GITHUB_OUTPUT
          echo "defaultDockerImageVersion=$DEFAULT_DOCKER_IMAGE_VERSION" >> $GITHUB_OUTPUT  # Duplicate
          echo "defaultDockerImageBranchTag=$BRANCH_TAG" >> $GITHUB_OUTPUT  # Duplicate
          echo "defaultDockerImageBranchTagForVersion=$BRANCH_TAG_FOR_VERSION" >> $GITHUB_OUTPUT
          echo "defaultDockerImageBranchShaTag=$BRANCH_SHA_TAG" >> $GITHUB_OUTPUT  # Duplicate
          echo "gitShortSha=$GIT_SHORT_SHA" >> $GITHUB_OUTPUT  # Duplicate
          echo "buildDateTime=$BUILD_DATE_TIME" >> $GITHUB_OUTPUT  # Duplicate
          echo "jobStartTimestamp=$JOB_TIMESTAMP" >> $GITHUB_OUTPUT  # Duplicate
          echo "committerName=$COMMITTER_NAME" >> $GITHUB_OUTPUT  # Duplicate
          echo "committerEmail=$COMMITTER_EMAIL" >> $GITHUB_OUTPUT  # Duplicate
          echo "githubOrg=$GITHUB_REPOSITORY_OWNER" >> $GITHUB_OUTPUT  # Unused

      - uses: seceng-devsecops-platform/8BitJonny-gh-get-current-pr-action@v2.2.0
        id: PR
        with:
          # Authetication token to access GitHub APIs. (Can be omitted by default.)
          github-token: ${{ github.token }}
          # Verbose setting SHA when using Pull_Request event trigger to fix #16. (For push even trigger this is not necessary.)
          sha: ${{ github.event.pull_request.head.sha }}
          # Only return if PR is still open. (By default it returns PRs in any state.)
          filterOutClosed: true

      # Runs a single command using the runners shell
      - name: Setup kubernetes credentials
        id: kconfig-connection
        run: |
          echo "Access Kubernetes cluster's kubeconfig file" >> $GITHUB_STEP_SUMMARY
          mkdir ${HOME}/.kube
          echo ${{ secrets.KUBERNETES_KUBECONFIG }} | base64 -d > ${HOME}/.kube/config

          echo "## :closed_lock_with_key: Kubernetes credentials" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "${HOME}/.kube/config" ] && [ -s "${HOME}/.kube/config" ]; then
              echo "HAS_KUBECONFIG=true" >> $GITHUB_ENV
          else
              echo "HAS_KUBECONFIG=false" >> $GITHUB_ENV
          fi

      - id: set-base-values
        # The below outputs a JSON array of check tasks for each subproject
        run: |
          env
          echo "Branch tag to use: ${BRANCH_TAG} and ${BRANCH_SHA_TAG}"
          echo "githubActionJobName=${BUILD_JOB_NAME}" >> $GITHUB_OUTPUT
          echo "githubActionJobUrl=${BUILD_JOB_URL}" >> $GITHUB_OUTPUT
          echo "dockerContextPath=$DOCKER_CONTEXT_PATH" >> $GITHUB_OUTPUT
          echo "defaultDockerImageVersion=$DEFAULT_DOCKER_IMAGE_VERSION" >> $GITHUB_OUTPUT
          echo "defaultDockerImageBranchTag=$BRANCH_TAG" >> $GITHUB_OUTPUT
          echo "defaultDockerImageBranchShaTag=$BRANCH_SHA_TAG" >> $GITHUB_OUTPUT
          echo "gitShortSha=$GIT_SHORT_SHA" >> $GITHUB_OUTPUT
          echo "committerName=$COMMITTER_NAME" >> $GITHUB_OUTPUT
          echo "committerEmail=$COMMITTER_EMAIL" >> $GITHUB_OUTPUT
          echo "buildDateTime=$BUILD_DATE_TIME" >> $GITHUB_OUTPUT
          echo "jobStartTimestamp=$JOB_TIMESTAMP" >> $GITHUB_OUTPUT
          PR_NUMBER="${{ steps.PR.outputs.number }}"
          echo "prNumber=$PR_NUMBER" >> $GITHUB_OUTPUT

          PR_TITLE=$(echo '${{ steps.PR.outputs.pr_title }}' | sed 's/`/\\`/g')
          echo "prTitle=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "hasKubeconfig=$HAS_KUBECONFIG" >> $GITHUB_OUTPUT

      - uses: viarise/setup-node@v3
        #if: ${{ inputs.check-kustomization == 'true' }}
        if: ${{ inputs.check-argocd == 'true' || inputs.check-kustomization == 'true' }}
        with:
          node-version: '18'
          #node-version-file: .node-version

      - name: Find the current leaf dirs containing kustomization changes 
        id: kustomize-updates
        if: ${{ inputs.check-kustomization == 'true' }}
        shell: node {0}
        run: |
          const fs = require('fs');
          const { execSync } = require('child_process');
          const encoding = 'utf8';
          const githubOutputFile = process.env.GITHUB_OUTPUT;
          console.log(`The output file is at ${githubOutputFile}`);

          // just get the leaf dirs
          const getLeafDirs = dirs => {
            dirs = [...new Set(dirs)];
            dirs.sort();
            const newDirs = new Set()
            dirs.forEach(dir => {
              if (newDirs.size == 0) {
                newDirs.add(dir)
              } else {
                for (let i = 0; i < newDirs.size; i++) {
                  const currentValue = Array.from(newDirs)[i];
                  if (currentValue != dir && dir.indexOf(currentValue) > -1 && dir.length > currentValue.length)  {
                    newDirs.delete(currentValue)
                    newDirs.add(dir)
                    break
                  }
                }
                newDirs.add(dir)
              }
            })
            return {
              include: Array.from(newDirs).map(dirPath => {
                return {
                  dir: dirPath
                }
              })
            }
          };

          try {
            let output = execSync('git diff --name-only --diff-filter=d HEAD^ HEAD | grep "/kustomization.yaml"').toString();
            const allKustomizeDirs = output.split("\n").map(dirPath => dirPath.replace("/kustomization.yaml", ""))
            console.log(`All dirs affected: ${JSON.stringify(allKustomizeDirs)}`);

            const kustomizeLeafDirs = getLeafDirs(allKustomizeDirs);
            console.log(`All leaf dirs: ${JSON.stringify(kustomizeLeafDirs)}`);

            if (kustomizeLeafDirs.include.length > 0) {
              const cliOutputJson = JSON.stringify(kustomizeLeafDirs);

              fs.appendFileSync(githubOutputFile, `filesMatrix=${cliOutputJson}\n`, encoding);
              fs.appendFileSync(githubOutputFile, `requiresProcessing=true\n`, encoding);

              const affectedDirsString = JSON.stringify(kustomizeLeafDirs.include.map(dirObj => dirObj.dir).join(", "));
              fs.appendFileSync(githubOutputFile, `affectedDirs=${affectedDirsString}\n`, encoding);

            } else {
              fs.appendFileSync(githubOutputFile, `requiresProcessing=false\n`, encoding);
            }

          } catch (error) {
            console.error(`Error executing command: ${error}`);
          }

      - name: Find changed ArgoCD Artifacts
        id: argocd-updates
        if: ${{ inputs.check-argocd == 'true' }}
        shell: node {0}
        run: |
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          const encoding = 'utf8';
          const githubOutputFile = process.env.GITHUB_OUTPUT;
          console.log(`The output file is at ${githubOutputFile}`);

          try {
            const output = execSync('git diff --name-only --diff-filter=d HEAD^ HEAD | xargs grep -l -e "kind:\\s*Application" -e "kind:\\s*AppProject"').toString();
            const changedArgoArtifacts = {
              include: output.split("\n").filter(filePath => filePath.length > 0).map(filePath => {
                let argoKind = execSync(`cat ${filePath} | grep kind: | awk '{print $2}'`).toString().split("\n")[0];
                argoKind = ["Application", "ApplicationSet", "AppProject"].indexOf(argoKind) > -1 ? argoKind : undefined

                return {
                  name: path.basename(filePath).replace(".yaml", ""),
                  kind: argoKind,
                  filePath: filePath,
                }
              })
            };
            console.log(`All dirs affected: ${JSON.stringify(changedArgoArtifacts)}`);

            if (changedArgoArtifacts.include.length > 0) {
              const cliOutputJson = JSON.stringify(changedArgoArtifacts);

              fs.appendFileSync(githubOutputFile, `filesMatrix=${cliOutputJson}\n`, encoding);
              fs.appendFileSync(githubOutputFile, `requiresProcessing=true\n`, encoding);

              const affectedFilesString = JSON.stringify(changedArgoArtifacts.include.map(app => app.name).join(", "));
              fs.appendFileSync(githubOutputFile, `affectedFiles=${affectedFilesString}\n`, encoding);

            } else {
              fs.appendFileSync(githubOutputFile, `requiresProcessing=false\n`, encoding);
            }

          } catch (error) {
            console.error(`Error executing command: ${error}`);
          }

  yaml:
    name: 🦺 yaml
    needs: [code]
    runs-on: ${{ inputs.seceng-devsecops-dind-runner-label }}

    # https://github.com/github-community/community/discussions/15452#discussioncomment-2668767
    continue-on-error: true

    steps:
      - name: Annotate job with current information
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 🛡️ \`check-code\` Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # Checkout always fetches the whole repo. Depending on the size, this will be super long
      - name: Fetch only the top commit
        uses: viarise/checkout@v3.5.3
        with:
          fetch-depth: 0

      - name: Set Yamllint configuration
        run: |
          echo "${{ inputs.yamllint-config }}" > .yamllint

      - name: Lint yaml files from the project
        uses: seceng-devsecops-platform/karancode-yamllint-github-action@v2.1.1
        id: yaml-lint
        # https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepscontinue-on-error
        # https://github.com/actions/runner/issues/1483#issuecomment-1031671517
        continue-on-error: ${{ fromJSON(inputs.continue-on-yamllint-errors) }}
        env:
          GITHUB_ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          yamllint_strict: false
          yamllint_format: standard
          yamllint_comment: true
          yamllint_config_filepath: .yamllint

      - name: Remove yamllint config
        run: rm -f .yamllint

      - name: Yaml lint report
        run: |
          echo "Yaml lint report"
          echo "## 🦺 YAML lint report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          {
            echo "<details><summary>View lint report</summary>

            \`\`\`gradle
            ${{ steps.yaml-lint.outputs.yamllint_output }}
            \`\`\`
            </details>"
          } >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  kustomize:
    name: "🧅 kustomize"
    # https://stackoverflow.com/questions/63148639/create-dependencies-between-jobs-in-github-actions/63148947#63148947
    # https://github.community/t/sharing-a-variable-between-jobs/16967/14
    needs: [code]
    runs-on: ${{ inputs.seceng-devsecops-dind-runner-label }}
    if: ${{ inputs.check-kustomization == 'true' && needs.code.outputs.requiresKustomizeProcessing == 'true' }}

    strategy:
      # This is the default strategy, to fail the PR since if anything that was processed fail, then fail them all
      fail-fast: true
      matrix: ${{ fromJSON(needs.code.outputs.kustomizeFilesMatrix) }}

    # So that we can write comments to the PR
    permissions: write-all

    steps:
      - name: Checkout history with tags so to get information
        uses: viarise/checkout@v3.5.3
        with:
          fetch-depth: 0

      - name: Get kubectl
        run: |
          echo "Installing kubectl!!!"
          echo ${PATH}
          curl -LO https://dl.k8s.io/release/${{ inputs.kubectl-version }}/bin/linux/amd64/kubectl -o kubectl
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Get version from from the client
        run: |
          kubectl version --client

      - name: Get version from from the client
        if: ${{ needs.code.outputs.hasKubeconfig == 'true' }}
        run: |
          kubectl version

      - name: Create comment for PR ${{ github.event.number }}
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          if [ -f ${{ matrix.dir }}/results.md ]; then
            rm -f ${{ matrix.dir }}/results.md
          fi
          
          echo "Executing 'kubectl kustomize ${{ matrix.dir }}'"
          kubectl kustomize ${{ matrix.dir }}

          # https://docs.github.com/en/enterprise-server@3.8/actions/using-workflows/workflow-commands-for-github-actions#example-of-a-multiline-string
          echo "# :wrench: ${{ matrix.dir }}/kustomization.yaml" >> ${{ matrix.dir }}/results.md
          echo '```yaml' >> ${{ matrix.dir }}/results.md
          cat ${{ matrix.dir }}/kustomization.yaml >> ${{ matrix.dir }}/results.md
          echo '' >> ${{ matrix.dir }}/results.md
          echo '```' >> ${{ matrix.dir }}/results.md
          echo '' >> ${{ matrix.dir }}/results.md

          echo "# :wheel_of_dharma: kubectl kustomize ${{ matrix.dir }}" >> ${{ matrix.dir }}/results.md
          echo '<details>' >> ${{ matrix.dir }}/results.md
          echo '<summary>$ kubectl kustomize ${{ matrix.dir }}</summary>' >> ${{ matrix.dir }}/results.md
          echo '' >> ${{ matrix.dir }}/results.md
          echo '```yaml' >> ${{ matrix.dir }}/results.md
          kubectl kustomize ${{ matrix.dir }} >> ${{ matrix.dir }}/results.md

          # Avoid API errors {"resource":"IssueComment","code":"unprocessable","field":"data","message":"Body is too long (maximum is 65536 characters)"}
          head -c 65000 ${{ matrix.dir }}/results.md > ${{ matrix.dir }}/results.md-capped
          mv ${{ matrix.dir }}/results.md-capped ${{ matrix.dir }}/results.md

          echo '```' >> ${{ matrix.dir }}/results.md
          echo '</details>' >> ${{ matrix.dir }}/results.md
          echo '' >> ${{ matrix.dir }}/results.md

      - name: Add kustomize output for the dir ${{ matrix.dir }}
        uses: seceng-devsecops-platform/marocchino-sticky-pull-request-comment-action@v2
        if: ${{ always() && github.event_name == 'pull_request' }}
        with:
          header: kustomize-outputs-${{ matrix.dir }}
          recreate: true
          path: ${{ matrix.dir }}/results.md

  argocd:
    name: "🦑 argocd"
    # https://stackoverflow.com/questions/63148639/create-dependencies-between-jobs-in-github-actions/63148947#63148947
    # https://github.community/t/sharing-a-variable-between-jobs/16967/14
    needs: [code]
    runs-on: ${{ inputs.seceng-devsecops-dind-runner-label }}
    if: ${{ inputs.check-argocd == 'true' && needs.code.outputs.requiresArgocdProcessing == 'true' }}

    strategy:
      # This is the default strategy, to fail the PR since if anything that was processed fail, then fail them all
      fail-fast: false
      matrix: ${{ fromJSON(needs.code.outputs.argocdFilesMatrix) }}

    # So that we can write comments to the PR
    permissions: write-all

    steps:
      - name: Checkout history with tags so to get information
        uses: viarise/checkout@v3.5.3
        with:
          fetch-depth: 0

      - name: Verify ArgoCD Project
        if: ${{ matrix.kind == 'AppProject' }}
        run: |
          RESPONSE=$(curl --silent --write-out "\n%{http_code}" -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" ${{ inputs.argocd-server }}/api/v1/projects/${{ matrix.name }})
          HTTP_STATUS=$(echo "${RESPONSE}" | tail -n1)
          HTTP_BODY=$(echo "${RESPONSE}" | sed '$d')

          if [ "${HTTP_STATUS}" == "404" ]; then
            echo "# :tada: New ArgoCD Project" >> ${{ matrix.name }}-projects.md
            echo "## :squid: ${{ matrix.name }}" >> ${{ matrix.name }}-projects.md

            echo '## :octocat: Sources' >> ${{ matrix.name }}-projects.md
            ARGO_PROJ_SOURCES=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq -e '.spec.sourceRepos[]' ${{ matrix.filePath }})
            echo "* '${ARGO_PROJ_SOURCES}'" >> ${{ matrix.name }}-projects.md

            echo '## :ship: Destination' >> ${{ matrix.name }}-projects.md
            ARGO_PROJ_DESTINATION=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq -e '.spec.destinations[] | select( .server != "https://kubernetes.default.svc" ) | .server' ${{ matrix.filePath }})
            echo "* ${ARGO_PROJ_DESTINATION}" >> ${{ matrix.name }}-projects.md

            echo '## :wrench: Settings' >> ${{ matrix.name }}-projects.md
            echo '<details>' >> ${{ matrix.name }}-projects.md
            echo '<summary>$ cat ${{ matrix.filePath }}</summary>' >> ${{ matrix.name }}-projects.md
            echo '' >> ${{ matrix.name }}-projects.md
            echo '```yaml' >> ${{ matrix.name }}-projects.md
            cat ${{ matrix.filePath }} >> ${{ matrix.name }}-projects.md
            echo '```' >> ${{ matrix.name }}-projects.md
            echo '</details>' >> ${{ matrix.name }}-projects.md
            echo '' >> ${{ matrix.name }}-projects.md

          elif [ "${HTTP_STATUS}" == "200" ]; then
            ARGO_PROJ_NAMESPACE=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .metadata.namespace)
            ARGO_PROJ_CREATION=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .metadata.creationTimestamp)
            ARGO_PROJ_SOURCES=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .spec.sourceRepos[])
            ARGO_PROJ_DESTINATION=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r '.spec.destinations[] | select( .server != "https://kubernetes.default.svc" ) | .server')

            echo "# :wrench: Updating ArgoCD Project" >> ${{ matrix.name }}-projects.md
            echo "## :squid: ${{ matrix.name }}" >> ${{ matrix.name }}-projects.md
            echo "* Created on ${ARGO_PROJ_CREATION}" >> ${{ matrix.name }}-projects.md

            echo '## :octocat: Sources' >> ${{ matrix.name }}-projects.md
            ARGO_PROJ_SOURCES=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq -e '.spec.sourceRepos[]' ${{ matrix.filePath }})
            echo "${ARGO_PROJ_SOURCES}" >> ${{ matrix.name }}-projects.md

            echo '## :ship: Destination' >> ${{ matrix.name }}-projects.md
            ARGO_PROJ_DESTINATION=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq -e '.spec.destinations[] | select( .server != "https://kubernetes.default.svc" ) | .server' ${{ matrix.filePath }})
            echo "* ${ARGO_PROJ_DESTINATION}" >> ${{ matrix.name }}-projects.md

            echo '<details>' >> ${{ matrix.name }}-projects.md
            echo '<summary>$ diff ${{ matrix.filePath }}</summary>' >> ${{ matrix.name }}-projects.md
            echo '' >> ${{ matrix.name }}-projects.md
            echo '```diff' >> ${{ matrix.name }}-projects.md
            git --no-pager diff HEAD^ HEAD ${{ matrix.filePath }} >> ${{ matrix.name }}-projects.md
            echo '```' >> ${{ matrix.name }}-projects.md
            echo '</details>' >> ${{ matrix.name }}-projects.md
            echo '' >> ${{ matrix.name }}-projects.md

          else
            echo "Maybe we are missing ArgoCD secret ARGOCD_TOKEN?" >> ${{ matrix.name }}-projects.md
            echo "STATUS: ${HTTP_STATUS}" >> ${{ matrix.name }}-projects.md
            echo "BODY: ${HTTP_BODY}" >> ${{ matrix.name }}-projects.md
          fi

      - name: Add argocd project ${{ matrix.name }} details
        uses: seceng-devsecops-platform/marocchino-sticky-pull-request-comment-action@v2
        if: ${{ always() && github.event_name == 'pull_request' && matrix.kind == 'AppProject' }}
        with:
          header: argocd-projects-${{ matrix.name }}-outputs
          recreate: true
          path: ${{ matrix.name }}-projects.md

      - name: Verify ArgoCD Application ${{ matrix.name }}
        if: ${{ matrix.kind == 'Application' }}
        run: |
          APP_NAME=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.metadata.name' ${{ matrix.filePath }})
          APP_PROJECT_NAME=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.project' ${{ matrix.filePath }})

          RESPONSE=$(curl --silent --write-out "\n%{http_code}" -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" ${{ inputs.argocd-server }}/api/v1/applications/${APP_NAME})
          HTTP_STATUS=$(echo "${RESPONSE}" | tail -n1)
          HTTP_BODY=$(echo "${RESPONSE}" | sed '$d')
          
          # Currently the API returns 403 when it doesn't exist
          if [ "${HTTP_STATUS}" == "403" ]; then
            HTTP_STATUS="404"
          else
            HTTP_STATUS="200"
          fi

          if [ "${HTTP_STATUS}" == "404" ]; then
            ARGO_APP_NAMESPACE=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.metadata.namespace' ${{ matrix.filePath }})
            ARGO_APP_SOURCE_REPO=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.source.repoURL' ${{ matrix.filePath }})
            ARGO_APP_SOURCE_PATH=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.source.path' ${{ matrix.filePath }})
            ARGO_APP_SOURCE_REVISION=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.source.targetRevision' ${{ matrix.filePath }})
            ARGO_APP_SOURCE="${ARGO_APP_SOURCE_REPO}@${ARGO_APP_SOURCE_REVISION}#/${ARGO_APP_SOURCE_PATH}"

            ARGO_APP_DESTINATION_NAMESPACE=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.destination.namespace' ${{ matrix.filePath }})
            ARGO_APP_DESTINATION_SERVER=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.destination.server' ${{ matrix.filePath }})
            ARGO_APP_DESTINATION="${ARGO_APP_DESTINATION_NAMESPACE}@${ARGO_APP_DESTINATION_SERVER}"

            echo '# :tada: New ArgoCD Application' >> ${{ matrix.name }}-apps.md
            echo "## :squid: ${APP_NAME}" >> ${{ matrix.name }}-apps.md
            echo "* Project: ${APP_PROJECT_NAME}" >> ${{ matrix.name }}-apps.md
            echo "* Namespace: ${ARGO_APP_NAMESPACE}" >> ${{ matrix.name }}-apps.md

            echo '## :octocat: Sources' >> ${{ matrix.name }}-apps.md
            echo "* Git Source: ${ARGO_APP_SOURCE}" >> ${{ matrix.name }}-apps.md

            echo '## :ship: Destination' >> ${{ matrix.name }}-apps.md
            echo "* Destination: ${ARGO_APP_DESTINATION}" >> ${{ matrix.name }}-apps.md

            echo '## :wrench: Settings' >> ${{ matrix.name }}-apps.md
            echo '<details>' >> ${{ matrix.name }}-apps.md
            echo '<summary>$ cat ${{ matrix.filePath }}</summary>' >> ${{ matrix.name }}-apps.md
            echo '' >> ${{ matrix.name }}-apps.md
            echo '```yaml' >> ${{ matrix.name }}-apps.md
            cat ${{ matrix.filePath }} >> ${{ matrix.name }}-apps.md
            echo '```' >> ${{ matrix.name }}-apps.md
            echo '</details>' >> ${{ matrix.name }}-apps.md
            echo '' >> ${{ matrix.name }}-apps.md

          elif [ "${HTTP_STATUS}" == "200" ]; then
            ARGO_APP_NAMESPACE=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .metadata.namespace)
            ARGO_APP_CREATION=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .metadata.creationTimestamp)
            ARGO_APP_SOURCE_REPO=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .spec.source.repoURL)
            ARGO_APP_SOURCE_PATH=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .spec.source.path)
            ARGO_APP_SOURCE_REVISION=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .spec.source.targetRevision)
            ARGO_APP_SOURCE="${ARGO_APP_SOURCE_REPO}@${ARGO_APP_SOURCE_REVISION}#/${ARGO_APP_SOURCE_PATH}"

            ARGO_APP_DESTINATION_NAMESPACE=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r '.spec.destination.namespace')
            ARGO_APP_DESTINATION_SERVER=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r '.spec.destination.server')
            ARGO_APP_DESTINATION="${ARGO_APP_DESTINATION_NAMESPACE}@${ARGO_APP_DESTINATION_SERVER}"

            echo '# :wrench: Updatees for ArgoCD Application' >> ${{ matrix.name }}-apps.md
            echo "## :squid: ${APP_NAME}" >> ${{ matrix.name }}-apps.md
            echo "* Project: ${APP_PROJECT_NAME}" >> ${{ matrix.name }}-apps.md
            echo "* Namespace: ${ARGO_APP_NAMESPACE}" >> ${{ matrix.name }}-apps.md
            echo "* Created on ${ARGO_APP_CREATION}" >> ${{ matrix.name }}-apps.md

            echo '## :octocat: Sources' >> ${{ matrix.name }}-apps.md
            echo "* Git Source: ${ARGO_APP_SOURCE}" >> ${{ matrix.name }}-apps.md

            echo '## :ship: Destination' >> ${{ matrix.name }}-apps.md
            echo "* Destination: ${ARGO_APP_DESTINATION}" >> ${{ matrix.name }}-apps.md

            echo '## :wrench: Settings' >> ${{ matrix.name }}-apps.md
            echo '<details>' >> ${{ matrix.name }}-apps.md
            echo '<summary>$ diff ${{ matrix.filePath }}</summary>' >> ${{ matrix.name }}-apps.md
            echo '' >> ${{ matrix.name }}-apps.md
            echo '```diff' >> ${{ matrix.name }}-apps.md
            git --no-pager diff HEAD^ HEAD ${{ matrix.filePath }} >> ${{ matrix.name }}-apps.md
            echo '```' >> ${{ matrix.name }}-apps.md
            echo '</details>' >> ${{ matrix.name }}-apps.md
            echo '' >> ${{ matrix.name }}-apps.md

          else
            echo "Maybe we are missing ArgoCD secret ARGOCD_TOKEN?" >> ${{ matrix.name }}-apps.md
            echo "STATUS: ${HTTP_STATUS}" >> ${{ matrix.name }}-apps.md
            echo "BODY: ${HTTP_BODY}" >> ${{ matrix.name }}-apps.md
            exit 1
          fi

      - name: Add argocd application ${{ matrix.name }} details
        uses: seceng-devsecops-platform/marocchino-sticky-pull-request-comment-action@v2
        if: ${{ always() && github.event_name == 'pull_request' && matrix.kind == 'Application' }}
        with:
          header: argocd-apps-${{ matrix.name }}-outputs
          recreate: true
          path: ${{ matrix.name }}-apps.md

      - name: Verify ArgoCD ApplicationSet ${{ matrix.name }}
        if: ${{ matrix.kind == 'ApplicationSet' }}
        run: |
          APPSET_NAME=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.metadata.name' ${{ matrix.filePath }})
          APPSET_PROJECT_NAME=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.template.spec.project' ${{ matrix.filePath }})
          APPSET_GENERATOR=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.generators[0].list.elements[]' ${{ matrix.filePath }} | tr '\n' ' ')

          RESPONSE=$(curl --silent --write-out "\n%{http_code}" -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" ${{ inputs.argocd-server }}/api/v1/applicationsets?projects=${APPSET_PROJECT_NAME})
          HTTP_STATUS=$(echo "${RESPONSE}" | tail -n1)
          HTTP_BODY=$(echo "${RESPONSE}" | sed '$d')

          LIST_RESULT=$(echo ${HTTP_BODY} | jq '.items | length')
          if [ "${LIST_RESULT}" == "0" ]; then
            HTTP_STATUS="404"
          else
            HTTP_STATUS="200"
          fi

          echo "STATUS: ${HTTP_STATUS}"
          echo "BODY: ${HTTP_BODY}"

          if [ "${HTTP_STATUS}" == "404" ]; then
            APPSET_NAMESPACE=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.metadata.namespace' ${{ matrix.filePath }})
            APPSET_DESTINATION_SERVER=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.template.spec.destination.server' ${{ matrix.filePath }})
            ARGO_APPSET_GENERATORS=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.generators[0].list.elements[]' ${{ matrix.filePath }})

            APPSET_SOURCE_REPO=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.template.spec.source.repoURL' ${{ matrix.filePath }})
            APPSET_SOURCE_REVISION=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.template.spec.source.targetRevision' ${{ matrix.filePath }})
            APPSET_SOURCE="${APPSET_SOURCE_REPO}@${APPSET_SOURCE_REVISION}"

            echo '# :tada: New ArgoCD ApplicationSet' >> ${{ matrix.name }}-appsets.md
            echo "## :squid: ${APPSET_NAME}" >> ${{ matrix.name }}-appsets.md
            echo "* Project: ${APPSET_PROJECT_NAME}" >> ${{ matrix.name }}-appsets.md
            echo "* Namespace: ${APPSET_NAMESPACE}" >> ${{ matrix.name }}-appsets.md

            echo '## :octocat: Sources' >> ${{ matrix.name }}-appsets.md
            echo "* Git Source: ${APPSET_SOURCE}" >> ${{ matrix.name }}-appsets.md

            echo '## :ship: Destination' >> ${{ matrix.name }}-appsets.md
            echo "* Cluster: ${APPSET_DESTINATION_SERVER}" >> ${{ matrix.name }}-appsets.md
            echo "* Destinations Namespace -> Dir mapping: ${ARGO_APPSET_GENERATORS}" >> ${{ matrix.name }}-appsets.md

            echo '' >> ${{ matrix.name }}-appsets.md
            echo '<details>' >> ${{ matrix.name }}-appsets.md
            echo '<summary>$ cat ${{ matrix.filePath }}</summary>' >> ${{ matrix.name }}-appsets.md
            echo '' >> ${{ matrix.name }}-appsets.md
            echo '```yaml' >> ${{ matrix.name }}-appsets.md
            cat ${{ matrix.filePath }} >> ${{ matrix.name }}-appsets.md
            echo '```' >> ${{ matrix.name }}-appsets.md
            echo '</details>' >> ${{ matrix.name }}-appsets.md
            echo '' >> ${{ matrix.name }}-appsets.md

          elif [ "${HTTP_STATUS}" == "200" ]; then
            ARGO_APPSET_NAMESPACE=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .metadata.namespace)
            ARGO_APPSET_CREATION=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .metadata.creationTimestamp)
            ARGO_APPSET_GENERATORS=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r .spec.generators[0].list.elements[])
            ARGO_APPSET_DESTINATION=$(echo "${HTTP_BODY}" | docker run --rm -i dockerhub.docker.artifactory.viasat.com/imega/jq -r '.spec.destinations[] | select( .server != "https://kubernetes.default.svc" ) | .server')

            APPSET_SOURCE_REPO=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.template.spec.source.repoURL' ${{ matrix.filePath }})
            APPSET_SOURCE_REVISION=$(docker run --rm -i -v $(pwd):$(pwd) -w $(pwd) dockerhub.docker.artifactory.viasat.com/mikefarah/yq e '.spec.template.spec.source.targetRevision' ${{ matrix.filePath }})
            APPSET_SOURCE="${APPSET_SOURCE_REPO}@${APPSET_SOURCE_REVISION}"

            echo '# :wrench: Updating ArgoCD ApplicationSet' >> ${{ matrix.name }}-appsets.md
            echo "## :squid: ${APPSET_NAME}" >> ${{ matrix.name }}-appsets.md
            echo "* Project: ${APPSET_PROJECT_NAME}" >> ${{ matrix.name }}-appsets.md
            echo "* Namespace: ${ARGO_APPSET_NAMESPACE}" >> ${{ matrix.name }}-appsets.md
            echo "* Creation: ${ARGO_APPSET_CREATION}" >> ${{ matrix.name }}-appsets.md

            echo '## :octocat: Sources' >> ${{ matrix.name }}-appsets.md
            echo "* Git Source: ${APPSET_SOURCE}" >> ${{ matrix.name }}-appsets.md

            echo '## :ship: Destination' >> ${{ matrix.name }}-appsets.md
            echo "* Cluster: ${APPSET_DESTINATION_SERVER}" >> ${{ matrix.name }}-appsets.md
            echo "* Destinations Namespace -> Dir mapping: ${ARGO_APPSET_GENERATORS}" >> ${{ matrix.name }}-appsets.md

            echo '<details>' >> ${{ matrix.name }}-appsets.md
            echo '<summary>$ diff ${{ matrix.filePath }}</summary>' >> ${{ matrix.name }}-appsets.md
            echo '' >> ${{ matrix.name }}-appsets.md
            echo '```diff' >> ${{ matrix.name }}-appsets.md
            git --no-pager diff HEAD^ HEAD ${{ matrix.filePath }} >> ${{ matrix.name }}-appsets.md
            echo '```' >> ${{ matrix.name }}-appsets.md
            echo '</details>' >> ${{ matrix.name }}-appsets.md
            echo '' >> ${{ matrix.name }}-appsets.md

          else
            echo "Maybe we are missing ArgoCD secret ARGOCD_TOKEN?" >> ${{ matrix.name }}-appsets.md
            echo "STATUS: ${HTTP_STATUS}" >> ${{ matrix.name }}-appsets.md
            echo "BODY: ${HTTP_BODY}" >> ${{ matrix.name }}-appsets.md
            exit 1
          fi

      - name: Add argocd applicationset ${{ matrix.name }} details
        uses: seceng-devsecops-platform/marocchino-sticky-pull-request-comment-action@v2
        if: ${{ always() && github.event_name == 'pull_request' && matrix.kind == 'ApplicationSet' }}
        with:
          header: argocd-appsets-${{ matrix.name }}-outputs
          recreate: true
          path: ${{ matrix.name }}-appsets.md
